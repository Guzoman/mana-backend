const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const compression = require('compression');
const rateLimit = require('express-rate-limit');
const expressWs = require('express-ws');
const { Pool } = require('pg');
const jwt = require('jsonwebtoken');
const NodeCache = require('node-cache');
const winston = require('winston');
const { v4: uuidv4 } = require('uuid');

// Import route handlers
const authRoutes = require('./routes/auth');
const apiRoutes = require('./routes/api');
const accountRoutes = require('./routes/account');
const websocketHandler = require('./handlers/websocket');

const app = express();
const wsInstance = expressWs(app);

// Configuration
const config = {
  port: process.env.PORT || 3000,
  database: {
    host: process.env.DATABASE_HOST || 'mana-pg',
    port: parseInt(process.env.DATABASE_PORT) || 5432,
    database: process.env.DATABASE_NAME || 'mana',
    user: process.env.DATABASE_USER || 'mana',
    password: process.env.DATABASE_PASSWORD,
    ssl: process.env.DATABASE_SSL === 'true' ? { rejectUnauthorized: false } : false,
    max: 20,
    idleTimeoutMillis: 30000,
    connectionTimeoutMillis: 5000,
  },
  jwt: {
    secret: process.env.JWT_SECRET,
    ttl: parseInt(process.env.JWT_TTL) || 3600,
  },
  webauthn: {
    rpId: process.env.RP_ID || 'manaproyect.com',
    origin: process.env.ORIGIN || 'https://manaproyect.com',
  },
  flowise: {
    url: process.env.FLOWISE_URL || 'http://flowise:3000',
    serviceToken: process.env.FLOWISE_SERVICE_TOKEN,
  },
  zep: {
    bridgeUrl: process.env.ZEP_BRIDGE_URL || 'http://zep-bridge:5001',
  },
  corsOrigins: process.env.CORS_ORIGINS ? 
    process.env.CORS_ORIGINS.split(',').map(o => o.trim()) : 
    ['https://manaproyect.com'],
};

// Logging setup
const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: { service: 'mana-auth-bff' },
  transports: [
    new winston.transports.Console({ format: winston.format.simple() })
  ],
});

// Database setup
const pool = new Pool(config.database);

pool.on('error', (err) => {
  logger.error('PostgreSQL pool error:', err);
});

// Test database connection
pool.query('SELECT NOW()', (err, result) => {
  if (err) {
    logger.error('Database connection failed:', err);
    process.exit(1);
  } else {
    logger.info('Database connected successfully');
  }
});

// Cache setup
const challengeCache = new NodeCache({ 
  stdTTL: 300,
  checkperiod: 60 
});

// Middleware setup
app.use((req, res, next) => {
  req.id = uuidv4();
  res.setHeader('X-Request-ID', req.id);
  next();
});

app.use(helmet({ contentSecurityPolicy: false, crossOriginEmbedderPolicy: false }));
app.use(compression());
app.use(express.json({ limit: '1mb' }));
app.use(express.urlencoded({ extended: true, limit: '1mb' }));

// CORS configuration
const corsOptions = {
  origin: (origin, callback) => {
    if (!origin) return callback(null, true);
    if (config.corsOrigins.includes(origin)) {
      callback(null, true);
    } else {
      logger.warn(`CORS blocked origin: ${origin}`);
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: false,
  methods: ['GET', 'POST', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With'],
  maxAge: 3600,
};

app.use(cors(corsOptions));

// Rate limiting
const createRateLimiter = (windowMs, max, message) => rateLimit({
  windowMs,
  max,
  message: { error: 'rate_limited', message, retryAfter: Math.ceil(windowMs / 1000) },
  standardHeaders: true,
  legacyHeaders: false,
  keyGenerator: (req) => `${req.ip}:${req.user?.sub || 'anonymous'}`,
});

app.use(createRateLimiter(60000, parseInt(process.env.RATE_LIMIT_MAX) || 100, 'Too many requests'));

// Request logging
app.use((req, res, next) => {
  const start = Date.now();
  res.on('finish', () => {
    const duration = Date.now() - start;
    logger.info('Request completed', {
      requestId: req.id,
      method: req.method,
      path: req.path,
      statusCode: res.statusCode,
      duration: `${duration}ms`,
      userAgent: req.get('User-Agent'),
      origin: req.get('Origin'),
    });
  });
  next();
});

// Make dependencies available to routes
app.locals.pool = pool;
app.locals.logger = logger;
app.locals.config = config;
app.locals.challengeCache = challengeCache;

// Health check
app.get('/health', async (req, res) => {
  try {
    await pool.query('SELECT 1');
    res.json({
      status: 'healthy',
      timestamp: new Date().toISOString(),
      version: '1.0.0',
      checks: { database: 'ok', memory: process.memoryUsage() }
    });
  } catch (error) {
    logger.error('Health check failed:', error);
    res.status(503).json({
      status: 'unhealthy',
      timestamp: new Date().toISOString(),
      error: error.message,
    });
  }
});

// WebSocket endpoint
app.ws('/ws', websocketHandler);

// API routes
app.use('/auth', createRateLimiter(60000, 30, 'Too many auth requests'), authRoutes);
app.use('/api', createRateLimiter(60000, 100, 'Too many API requests'), apiRoutes);
app.use('/account', createRateLimiter(60000, 10, 'Too many account requests'), accountRoutes);

// Error handling
app.use((req, res) => {
  res.status(404).json({
    error: 'not_found',
    message: 'Endpoint not found',
    path: req.path,
    method: req.method,
  });
});

app.use((err, req, res, next) => {
  logger.error('Unhandled error:', {
    requestId: req.id,
    error: err.message,
    stack: err.stack,
    path: req.path,
    method: req.method,
  });
  
  const isDevelopment = process.env.NODE_ENV !== 'production';
  res.status(err.status || 500).json({
    error: 'server_error',
    message: isDevelopment ? err.message : 'Internal server error',
    requestId: req.id,
    ...(isDevelopment && { stack: err.stack }),
  });
});

// Graceful shutdown
process.on('SIGINT', async () => {
  logger.info('Received SIGINT, shutting down gracefully...');
  await pool.end();
  process.exit(0);
});

process.on('SIGTERM', async () => {
  logger.info('Received SIGTERM, shutting down gracefully...');
  await pool.end();
  process.exit(0);
});

// Start server
const server = app.listen(config.port, '0.0.0.0', () => {
  logger.info(`Mana Auth BFF server listening on port ${config.port}`, {
    environment: process.env.NODE_ENV || 'development',
    corsOrigins: config.corsOrigins,
    rpId: config.webauthn.rpId,
  });
});

server.on('error', (error) => {
  logger.error('Server error:', error);
  process.exit(1);
});

module.exports = app;
